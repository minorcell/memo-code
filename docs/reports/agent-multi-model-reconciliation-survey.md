# Agent 多模型差异消解方案调研报告

## 1. 背景与问题定义

在 Agent 开发中，不同大模型对“工具调用（tool use / function calling）”的支持程度差异很大：

- 有的模型支持原生 tool use：能直接走平台提供的工具调用通道。
- 有的模型不支持：只能通过文本输出 JSON（如 `{"tool":"read","params":{...}}`）来“模拟调用”。

这种差异会带来：

- 代码路径分裂（同一 agent 逻辑要写多套）
- 稳定性问题（JSON 不规范、参数缺失、重复调用）
- 安全与权限风险（模型越权、误执行、重试造成副作用）

核心目标不是“让模型能力一致”，而是**让上层 Agent 逻辑不需要感知差异**，把差异收口到可控的工程层。

---

## 2. 关键结论（结论先行）

成熟产品普遍采用同一个思想：
**模型负责“决策与选择”，工具执行与编排由确定性系统负责；差异通过“适配层 + 统一中间表示（IR）”吸收。**

落地要点：

1. 设计内部统一的 **ToolCall IR**（工具调用中间表示），上层 agent 只与 IR 交互
2. 建立 **模型能力矩阵**，运行时协商选择“原生工具调用路径”或“结构化输出模拟路径”
3. 工具系统 **schema-first + 严格校验 + 幂等 + 权限分级**，不信任模型输出
4. 对非原生模型用 **JSON 输出 + 解析 + 修复（repair loop）** 提升鲁棒性
5. Claude Code CLI 的典型做法是：**工具内置、输出可机器读、并用 MCP 协议标准化外部工具接入**

---

## 3. 方案拆解：如何“消除差异”（工程视角）

### 3.1 统一 ToolCall IR（核心）

内部只认一种格式，例如：

- `ToolCall { name, arguments, call_id }`
- `ToolResult { call_id, ok, result | error }`

上层 agent（planning/memory/task graph/policy）只处理 IR：

- 不关心模型是否原生 tool use
- 不关心供应商 API 细节
- 不关心 JSON 解析策略

**收益：换模型只换 adapter，不改 agent 主体。**

---

### 3.2 能力矩阵 + 路由（运行时协商）

给每个模型配置能力项：

- 是否原生 tool use / function calling
- 是否支持强结构化输出（schema/grammar）
- 是否支持并行工具调用/流式 tool call
- JSON 自愈能力稳定性（经验指标）
- 上下文长度、多模态、系统提示兼容性等

按能力走两条主路径：

- **路径 A：原生 tool use**
  将工具 schema 映射到供应商的 tools/functions 格式 → 直接调用
- **路径 B：模拟 tool use**
  Prompt 要求仅输出 JSON（或 JSONL），加边界标记 → 解析/校验 → 执行 → 结果回填
  若失败：repair loop（同模型或更稳的“修复模型”纠正 JSON）

---

### 3.3 工具层需要“确定性与安全性”

成熟实现通常有这些硬约束：

- **入参 JSON Schema**：执行前严格校验（缺字段/类型不对直接拒绝）
- **幂等与 call_id**：避免重试导致重复写文件/重复下单
- **权限与沙箱**：read-only / write / network / exec 分级；敏感工具二次确认或策略放行
- **结构化错误**：错误码、是否可重试、部分结果，便于模型稳定地“下一步”

> 这部分是“真正消除差异”的护城河：不把可靠性寄托在模型上。

---

## 4. 成熟产品参考：Claude Code CLI 的启示

Claude Code CLI 的思路很典型：**把“世界”包装为工具/协议**，模型只做选择。

关键点（从总结角度）：

1. **内置工具体系**：如读写、搜索、命令执行等（工具是系统能力，不是模型能力）
2. **可机器读输出**：例如 JSON 输出格式，便于脚本/系统稳定解析
3. **MCP（Model Context Protocol）协议化接入**：将外部工具/数据源以标准协议接入，降低 N×M 集成复杂度
4. **插件化扩展**：用统一的扩展点（skills/subagents/hooks 等）组织能力，减少临时拼装

启示：

> 不要指望靠提示词统一所有模型，而要用“工具协议 + runtime 治理”统一能力边界。

---

## 5. LangChain / LangGraph / AI SDK 的作用定位

### 5.1 LangChain / LangGraph

**定位：应用层编排框架 + 生态**

- 提供模型/工具/检索/记忆的抽象接口
- 支持结构化输出解析、重试、修复等通用手段
- LangGraph 更适合复杂 agent：用“图/状态机”表达循环、分支、并行、失败重试、人审等

**能缓解：**多步流程编排、工具调用工程化、RAG 生态集成
**不能消除：**模型本身的稳定性差异与安全治理（仍需你做 runtime 权限/幂等/审计）

### 5.2 AI SDK（如面向 Web/Node 的 SDK）

**定位：产品工程向的接入与交互层**

- 多供应商统一调用
- 强 streaming（前后端、SSE/ReadableStream）与 UI 集成体验
- 工具调用能力通常也会封装，但对复杂 agent 编排不一定覆盖

**擅长：**快速做出可用产品体验（流式、前后端打通）
**不擅长：**复杂工作流编排与深度治理（更偏 orchestrator 的活）

---

## 6. 推荐架构（可落地的四层分层）

1. **Tool Runtime（确定性执行层）**
   schema 校验、权限控制、幂等、审计、沙箱
2. **Tool Protocol（协议/IR 层）**
   ToolCall/ToolResult IR；可选对外提供 MCP server
3. **Model Adapter（差异吸收层）**
    - 原生 tool use 映射器
    - JSON 模拟调用解析器 + repair loop
    - 能力矩阵路由

4. **Agent Core（业务编排层）**
   计划、记忆、策略、任务图、评测回放；完全不关心模型差异

---

## 7. 风险与对策（工程实践要点）

- **JSON 不稳定** → schema 校验 + repair loop + 降级策略（例如先产意图后规范化）
- **重复调用副作用** → 幂等键 + call_id + 工具侧事务/去重
- **越权与安全** → 工具权限分级 + 策略引擎 + 高危操作需确认/审批
- **模型能力不均导致体验波动** → 能力矩阵路由（关键任务用稳模型；弱模型仅做草案/意图）
- **可观测性不足** → tracing（每步 tool call、参数、结果、耗时、错误码）+ 评测集回放

---

## 8. 结论

- “消除模型差异”的正确方式不是让模型一致，而是**用统一 IR + adapter 把差异封装起来**。
- 框架（LangChain/LangGraph/AI SDK）更多是**降低工程成本**：提供抽象、编排、解析/重试与生态；但安全、幂等、权限等关键治理依然应在你自己的 Tool Runtime 中实现。
- Claude Code CLI 的关键经验是：**工具能力产品化 + 输出机器可读 + 通过协议（MCP）标准化扩展**，从而把复杂度从“模型差异”转移到“系统架构”。
